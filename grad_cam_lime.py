# -*- coding: utf-8 -*-
"""Grad-CAM_LIME.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T7ApmtrzaEUHEuxuhfPa5HOfukE4Amaz
"""

from google.colab import drive
drive.mount('/content/drive')

# import tensorflow as tf

# print("Num GPUs Available: ", len(tf.config.list_physical_devices('GPU')))
# tf.config.list_physical_devices('GPU')

import tensorflow as tf

# Set memory growth for GPU
gpus = tf.config.experimental.list_physical_devices('GPU')
if gpus:
    try:
        for gpu in gpus:
            tf.config.experimental.set_memory_growth(gpu, True)
    except RuntimeError as e:
        print(e)
else:
    print("No GPUs detected. Using CPU.")

"""# **Data load**"""

import numpy as np

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

print(f"Images shape: {images.shape}")  # This should show (7909, 224, 224, 3) or similar
print(f"Labels shape: {labels.shape}")  # This should show (7909,)

# You can now proceed with the rest of data preparation and modelling

import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model, Model
from tensorflow.keras.metrics import AUC
from sklearn.model_selection import train_test_split
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.stats import ttest_ind
import matplotlib.pyplot as plt

# Custom Sensitivity and Specificity Metrics
def sensitivity(y_true, y_pred):
    true_positives = tf.reduce_sum(tf.round(tf.clip_by_value(y_true * y_pred, 0, 1)))
    possible_positives = tf.reduce_sum(tf.round(tf.clip_by_value(y_true, 0, 1)))
    return true_positives / (possible_positives + tf.keras.backend.epsilon())

def specificity(y_true, y_pred):
    true_negatives = tf.reduce_sum(tf.round(tf.clip_by_value((1-y_true) * (1-y_pred), 0, 1)))
    possible_negatives = tf.reduce_sum(tf.round(tf.clip_by_value(1-y_true, 0, 1)))
    return true_negatives / (possible_negatives + tf.keras.backend.epsilon())

# Custom Weighted Binary Crossentropy
def weighted_binary_crossentropy(y_true, y_pred, weight_positive=1.0, weight_negative=1.0):
    y_true_float = tf.cast(y_true, tf.float32)
    bce = tf.keras.losses.binary_crossentropy(y_true_float, y_pred, from_logits=False)
    weight_vector = y_true_float * weight_positive + (1. - y_true_float) * weight_negative
    weighted_bce = weight_vector * bce
    return tf.reduce_mean(weighted_bce)

import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.metrics import AUC

# Load ResNet50 model
model_save_dir = "/content/drive/MyDrive/KaggleData/CrossValidationResults"
resnet50_model_path = os.path.join(model_save_dir, "resnet50.h5")

resnet50_model = load_model(resnet50_model_path, custom_objects={
    '<lambda>': lambda y_true, y_pred: weighted_binary_crossentropy(y_true, y_pred, weight_positive=1.0, weight_negative=1.0),
    'sensitivity': sensitivity,
    'specificity': specificity,
    'AUC': AUC
})

# Load EfficientNetB0 model
efnetB0_model_path = os.path.join(model_save_dir, "efnetB0.h5")

efnetB0_model = load_model(efnetB0_model_path, custom_objects={
    '<lambda>': lambda y_true, y_pred: weighted_binary_crossentropy(y_true, y_pred, weight_positive=1.0, weight_negative=1.0),
    'sensitivity': sensitivity,
    'specificity': specificity,
    'AUC': AUC
})

# Load DenseNet201 model
densenet201_model_path = os.path.join(model_save_dir, "densenet201_model.h5")

densenet201_model = load_model(densenet201_model_path, custom_objects={
    '<lambda>': lambda y_true, y_pred: weighted_binary_crossentropy(y_true, y_pred, weight_positive=1.0, weight_negative=1.0),
    'sensitivity': sensitivity,
    'specificity': specificity,
    'AUC': AUC
})

"""# **GRAD-CAM Explanations**"""



import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)
    print("Shape before adding batch dimension:", jet_heatmap.shape)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    print("Shape after adding batch dimension:", jet_heatmap.shape)
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    print("Shape after resizing and removing batch dimension:", jet_heatmap.shape)
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    plt.imshow(superimposed_img)
    plt.axis('off')
    plt.show()

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet')
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet')
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet')

# Define the layers to extract features from
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Sample image index (you can change this to visualize different images)
sample_index = 0
sample_image = images[sample_index]
sample_label = labels[sample_index]

# Generate Grad-CAM heatmaps for multiple layers
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)
    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")
        display_gradcam(sample_image, heatmap)

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet')
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet')
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet')

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Sample image index (you can change this to visualize different images)
sample_index = 0
sample_image = images[sample_index]
sample_label = labels[sample_index]

# Display original image
plt.figure(figsize=(10, 10))
plt.subplot(1, 1, 1)
plt.imshow(image.array_to_img(sample_image))
plt.title("Original Image")
plt.axis('off')
plt.show()

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)
    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        # Display original image and Grad-CAM side by side
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image.array_to_img(sample_image))
        plt.title("Original Image")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name} - {layer_name} Grad-CAM")
        plt.axis('off')
        plt.show()

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=True)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=True)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=True)

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Sample image index (you can change this to visualize different images)
sample_index = 0
sample_image = images[sample_index]
sample_label = labels[sample_index]

# Display original image
plt.figure(figsize=(10, 10))
plt.subplot(1, 1, 1)
plt.imshow(image.array_to_img(sample_image))
plt.title("Original Image")
plt.axis('off')
plt.show()

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        # Display original image and Grad-CAM side by side
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image.array_to_img(sample_image))
        plt.title(f"Original Image\nPrediction: {prediction}")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name} - {layer_name} Grad-CAM\nPrediction: {prediction}")
        plt.axis('off')
        plt.show()

# Sample image index (you can change this to visualize different images)
sample_index = 0

# Get the sample image and its ground truth label
sample_image = images[sample_index]
sample_label = labels[sample_index]

# Determine if the image is benign or malignant based on the ground truth label
if sample_label == 0:
    ground_truth = "Benign"
else:
    ground_truth = "Malignant"

# Display the original image with its ground truth label
plt.figure(figsize=(10, 10))
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Image\nGround Truth: {ground_truth}")
plt.axis('off')
plt.show()

print(f"The ground truth label for the sample image is: {ground_truth}")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=True)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=True)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=True)

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Find the first malignant image in the dataset
malignant_index = np.where(labels == 1)[0][0]
sample_image = images[malignant_index]
sample_label = labels[malignant_index]

# Display the original malignant image
plt.figure(figsize=(10, 10))
plt.imshow(image.array_to_img(sample_image))
plt.title("Original Malignant Image")
plt.axis('off')
plt.show()

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        # Display original image and Grad-CAM side by side
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image.array_to_img(sample_image))
        plt.title(f"Original Malignant Image\nPrediction: {prediction}")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name} - {layer_name} Grad-CAM\nPrediction: {prediction}")
        plt.axis('off')
        plt.show()

print(f"The ground truth label for the sample image is: Malignant")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import random

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=True)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=True)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=True)

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Function to randomly select a mispredicted malignant image
def find_mispredicted_malignant_image():
    malignant_indices = np.where(labels == 1)[0]
    random.shuffle(malignant_indices)

    for index in malignant_indices:
        sample_image = images[index]
        img_array = preprocess_image(sample_image, 'ResNet50')  # Use ResNet50 for initial prediction check
        preds = resnet50_model.predict(img_array)
        if preds[0][0] < 0.5:  # Misclassified as benign
            return index, sample_image, labels[index]
    return None, None, None

# Find a mispredicted malignant image
mispredicted_index, sample_image, sample_label = find_mispredicted_malignant_image()

if mispredicted_index is not None:
    # Display the mispredicted malignant image
    plt.figure(figsize=(10, 10))
    plt.imshow(image.array_to_img(sample_image))
    plt.title(f"Original Malignant Image (Mispredicted as Benign)\nIndex: {mispredicted_index}")
    plt.axis('off')
    plt.show()

    # Generate Grad-CAM heatmaps for multiple layers and compare with the original image
    for model_name, (model, layer_names) in models.items():
        img_array = preprocess_image(sample_image, model_name)

        # Get prediction
        preds = model.predict(img_array)
        if preds[0][0] >= 0.5:
            prediction = "Malignant"
        else:
            prediction = "Benign"

        for layer_name in layer_names:
            heatmap = make_gradcam_heatmap(img_array, model, layer_name)
            superimposed_img = display_gradcam(sample_image, heatmap)
            print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

            # Display original image and Grad-CAM side by side
            plt.figure(figsize=(10, 5))
            plt.subplot(1, 2, 1)
            plt.imshow(image.array_to_img(sample_image))
            plt.title(f"Original Malignant Image (Mispredicted as Benign)\nPrediction: {prediction}")
            plt.axis('off')

            plt.subplot(1, 2, 2)
            plt.imshow(superimposed_img)
            plt.title(f"{model_name} - {layer_name} Grad-CAM\nPrediction: {prediction}")
            plt.axis('off')
            plt.show()

    print(f"The ground truth label for the sample image is: Malignant")
else:
    print("No mispredicted malignant images found.")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import random

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=True)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=True)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=True)

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Randomly select a malignant image
malignant_indices = np.where(labels == 1)[0]
random_index = random.choice(malignant_indices)
sample_image = images[random_index]
sample_label = labels[random_index]

# Display the original malignant image
plt.figure(figsize=(10, 10))
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Malignant Image\nIndex: {random_index}")
plt.axis('off')
plt.show()

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        # Display original image and Grad-CAM side by side
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image.array_to_img(sample_image))
        plt.title(f"Original Malignant Image\nPrediction: {prediction}")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name} - {layer_name} Grad-CAM\nPrediction: {prediction}")
        plt.axis('off')
        plt.show()

print(f"The ground truth label for the sample image is: Malignant")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import random

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=False)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=False)

# Add custom classification head (assuming the models are trained for binary classification)
def add_classification_head(model):
    x = tf.keras.layers.GlobalAveragePooling2D()(model.output)
    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    return tf.keras.models.Model(model.inputs, x)

resnet50_model = add_classification_head(resnet50_model)
efnetB0_model = add_classification_head(efnetB0_model)
densenet201_model = add_classification_head(densenet201_model)

# Compile the models (if needed)
resnet50_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
efnetB0_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
densenet201_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Randomly select a malignant image
malignant_indices = np.where(labels == 1)[0]
random_index = random.choice(malignant_indices)
sample_image = images[random_index]
sample_label = labels[random_index]

# Display the original malignant image
plt.figure(figsize=(10, 10))
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Malignant Image\nIndex: {random_index}")
plt.axis('off')
plt.show()

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        # Display original image and Grad-CAM side by side
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image.array_to_img(sample_image))
        plt.title(f"Original Malignant Image\nPrediction: {prediction}")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name} - {layer_name} Grad-CAM\nPrediction: {prediction}")
        plt.axis('off')
        plt.show()

    print(f"The ground truth label for the sample image is: Malignant")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import random

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=False)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=False)

# Add custom classification head (assuming the models are trained for binary classification)
def add_classification_head(model):
    x = tf.keras.layers.GlobalAveragePooling2D()(model.output)
    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    return tf.keras.models.Model(model.inputs, x)

resnet50_model = add_classification_head(resnet50_model)
efnetB0_model = add_classification_head(efnetB0_model)
densenet201_model = add_classification_head(densenet201_model)

# Compile the models (if needed)
resnet50_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
efnetB0_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
densenet201_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Randomly select a malignant image
malignant_indices = np.where(labels == 1)[0]
random_index = random.choice(malignant_indices)
sample_image = images[random_index]
sample_label = labels[random_index]

# Display the original malignant image
plt.figure(figsize=(20, 10))
plt.subplot(1, 7, 1)
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Malignant Image\nIndex: {random_index}")
plt.axis('off')

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
i = 2
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        plt.subplot(1, 7, i)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name}\n{layer_name}\nPrediction: {prediction}", fontsize=8)
        plt.axis('off')
        i += 1

plt.show()
print(f"The ground truth label for the sample image is: Malignant")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import random

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Define Grad-CAM function
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Function to display heatmap
def display_gradcam(img, heatmap, alpha=0.4):
    img = image.array_to_img(img)

    heatmap = np.uint8(255 * heatmap)
    jet = plt.cm.get_cmap("jet")

    # Apply colormap to heatmap
    jet_heatmap = jet(heatmap)[:, :, :3]
    jet_heatmap = np.uint8(jet_heatmap * 255)

    jet_heatmap = np.expand_dims(jet_heatmap, axis=0)  # Add batch dimension
    jet_heatmap = tf.image.resize(jet_heatmap, (img.height, img.width))
    jet_heatmap = np.squeeze(jet_heatmap, axis=0)  # Remove batch dimension
    jet_heatmap = image.array_to_img(jet_heatmap)

    img_array = image.img_to_array(img)
    jet_heatmap_array = image.img_to_array(jet_heatmap)

    superimposed_img = jet_heatmap_array * alpha + img_array
    superimposed_img = image.array_to_img(superimposed_img)

    return superimposed_img

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=False)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=False)

# Add custom classification head (assuming the models are trained for binary classification)
def add_classification_head(model):
    x = tf.keras.layers.GlobalAveragePooling2D()(model.output)
    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    return tf.keras.models.Model(model.inputs, x)

resnet50_model = add_classification_head(resnet50_model)
efnetB0_model = add_classification_head(efnetB0_model)
densenet201_model = add_classification_head(densenet201_model)

# Compile the models (if needed)
resnet50_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
efnetB0_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
densenet201_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Define the layers to extract features from (known to exist in the models)
layer_names_resnet50 = ['conv2_block3_out', 'conv3_block4_out']
layer_names_efnetB0 = ['block3a_expand_activation', 'block6a_expand_activation']
layer_names_densenet201 = ['conv2_block3_concat', 'conv4_block6_concat']

# Define models dictionary
models = {
    'ResNet50': (resnet50_model, layer_names_resnet50),
    'EfficientNetB0': (efnetB0_model, layer_names_efnetB0),
    'DenseNet201': (densenet201_model, layer_names_densenet201)
}

# Randomly select a malignant image
malignant_indices = np.where(labels == 1)[0]
random_index = random.choice(malignant_indices)
sample_image = images[random_index]
sample_label = labels[random_index]

# Display the original malignant image
plt.figure(figsize=(20, 10))
plt.subplot(1, 7, 1)
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Malignant Image\nIndex: {random_index}")
plt.axis('off')

# Generate Grad-CAM heatmaps for multiple layers and compare with the original image
i = 2
for model_name, (model, layer_names) in models.items():
    img_array = preprocess_image(sample_image, model_name)

    # Get prediction
    preds = model.predict(img_array)
    if preds[0][0] >= 0.5:
        prediction = "Malignant"
    else:
        prediction = "Benign"

    for layer_name in layer_names:
        heatmap = make_gradcam_heatmap(img_array, model, layer_name)
        superimposed_img = display_gradcam(sample_image, heatmap)
        print(f"{model_name} - Layer: {layer_name} Grad-CAM:")

        plt.subplot(1, 7, i)
        plt.imshow(superimposed_img)
        plt.title(f"{model_name}\n{layer_name}\nPrediction: {prediction}", fontsize=8)
        plt.axis('off')
        i += 1

plt.show()
print(f"The ground truth label for the sample image is: Malignant")







"""# **LIME**"""

# ! pip install lime

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet_preprocess_input
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess_input
from tensorflow.keras.applications.densenet import preprocess_input as densenet_preprocess_input
import lime
from lime import lime_image
import random
import matplotlib.pyplot as plt
from skimage.segmentation import mark_boundaries

# Load the full dataset
full_data_path = "/content/drive/MyDrive/KaggleData/ProcessedData/full_data.npy"
full_data = np.load(full_data_path, allow_pickle=True)

# Separate the images and labels
images = np.array([item[0] for item in full_data])
labels = np.array([item[1] for item in full_data])

# Load pre-trained models
resnet50_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False)
efnetB0_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=False)
densenet201_model = tf.keras.applications.DenseNet201(weights='imagenet', include_top=False)

# Add custom classification head (assuming the models are trained for binary classification)
def add_classification_head(model):
    x = tf.keras.layers.GlobalAveragePooling2D()(model.output)
    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    return tf.keras.models.Model(model.inputs, x)

resnet50_model = add_classification_head(resnet50_model)
efnetB0_model = add_classification_head(efnetB0_model)
densenet201_model = add_classification_head(densenet201_model)

# Compile the models (if needed)
resnet50_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
efnetB0_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
densenet201_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Function to preprocess the image for different models
def preprocess_image(img, model_name):
    img = np.expand_dims(img, axis=0)
    if model_name == 'ResNet50':
        return resnet_preprocess_input(img)
    elif model_name == 'EfficientNetB0':
        return efficientnet_preprocess_input(img)
    elif model_name == 'DenseNet201':
        return densenet_preprocess_input(img)
    else:
        return img

# Randomly select a malignant image
malignant_indices = np.where(labels == 1)[0]
random_index = random.choice(malignant_indices)
sample_image = images[random_index]
sample_label = labels[random_index]

# Display the original malignant image
plt.figure(figsize=(10, 5))
plt.imshow(image.array_to_img(sample_image))
plt.title(f"Original Malignant Image\nIndex: {random_index}")
plt.axis('off')
plt.show()

# LIME Analysis
print("Starting LIME analysis...")

# Define a prediction function for LIME
def predict_resnet50(images):
    images = np.array([resnet_preprocess_input(img) for img in images])
    predictions = resnet50_model.predict(images)
    return np.hstack((1 - predictions, predictions))

def predict_efnetB0(images):
    images = np.array([efficientnet_preprocess_input(img) for img in images])
    predictions = efnetB0_model.predict(images)
    return np.hstack((1 - predictions, predictions))

def predict_densenet201(images):
    images = np.array([densenet_preprocess_input(img) for img in images])
    predictions = densenet201_model.predict(images)
    return np.hstack((1 - predictions, predictions))

# Create a LIME explainer
explainer = lime_image.LimeImageExplainer()

# Perform LIME analysis for ResNet50
explanation_resnet = explainer.explain_instance(sample_image.astype('double'), predict_resnet50, top_labels=1, hide_color=0, num_samples=1000)

# Perform LIME analysis for EfficientNetB0
explanation_efnet = explainer.explain_instance(sample_image.astype('double'), predict_efnetB0, top_labels=1, hide_color=0, num_samples=1000)

# Perform LIME analysis for DenseNet201
explanation_densenet = explainer.explain_instance(sample_image.astype('double'), predict_densenet201, top_labels=1, hide_color=0, num_samples=1000)

# Visualize the explanations
temp, mask = explanation_resnet.get_image_and_mask(explanation_resnet.top_labels[0], positive_only=True, num_features=10, hide_rest=False)
plt.figure(figsize=(10, 5))
plt.subplot(1, 3, 1)
plt.imshow(mark_boundaries(temp / 255.0, mask))
plt.title('ResNet50')

temp, mask = explanation_efnet.get_image_and_mask(explanation_efnet.top_labels[0], positive_only=True, num_features=10, hide_rest=False)
plt.subplot(1, 3, 2)
plt.imshow(mark_boundaries(temp / 255.0, mask))
plt.title('EfficientNetB0')

temp, mask = explanation_densenet.get_image_and_mask(explanation_densenet.top_labels[0], positive_only=True, num_features=10, hide_rest=False)
plt.subplot(1, 3, 3)
plt.imshow(mark_boundaries(temp / 255.0, mask))
plt.title('DenseNet201')

plt.show()



